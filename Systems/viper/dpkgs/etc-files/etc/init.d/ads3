#! /bin/sh
#
# Aircraft Data System startup script
#
# . /etc/default/rcS

# set -x

# PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=dsm
NAME=dsm
DESC="dsm"

ruser=ads
server=server		# found in /etc/hosts

dsmpath=/var/tmp/code
fmwpath=$dsmpath/firmware
ftrpath=$dsmpath/filters
modpath=$dsmpath/modules
libpath=$dsmpath/lib

modconf=/etc/dsm_modules.conf

if [ ! -r $modconf ]; then
    echo "$modconf not found"
    exit 1
fi

vulcan=(`uname -a | grep vulcan`)

if [ -n "$vulcan" ]; then
    adspath=/opt/local/nidas/armbe
else
    adspath=/opt/local/nidas/arm
fi

# check if a module is loaded, if not insmod it
insmod_chk() {
    set -x
    module=$1
    shift 1
    if [ -n "$vulcan" ]; then
	lsmod | fgrep -q $module || insmod $modpath/$module.ko $@
    else
	lsmod | fgrep -q $module || insmod $module $@
    fi
    set +x
}

# check if a module is loaded, if so rmmod it
rmmod_chk() {
	lsmod | fgrep -q $1 && rmmod $1
}

# read stdin and return an array of module names:
#    the first word of each non-comment line in stdin
get_modules() {
    while read module rest_of_line; do
	# bash on the vipers doesn't support =~ operator
	# so we use egrep
	# [[ "$module" =~ '^ *$' ]] && continue	# empty line
	# [[ "$module" =~ '^ *#' ]] && continue	# comment line
	echo "$module" | egrep -q "^ *$" && continue	# empty line
	echo "$module" | egrep -q "^ *#" && continue	# comment line
        echo "$module"
    done
}

# read stdin to get the devdir option to the ioctl_fifo module
get_devdir() {
    local devdir="/dev"

    while read -a modline; do

	echo "${modline[@]}" | egrep -q "^ *$" && continue	# empty line
	echo "${modline[@]}" | egrep -q "^ *#" && continue	# comment line

	# look for devdir option
	if [[ "${modline[@]}" == *devdir=* ]]; then
	    for o in ${modline[*]}; do
		if [[ "$o" == devdir=* ]]; then
		    devdir=`echo "$o" | cut -f 2 -d =`
		fi
	    done
	fi
    done
    echo $devdir
}

#
# After RTLinux modules are loaded, create any necessary symbolic
# links between any character device files found on $devdir
# and /dev.  User space code opens the FIFOs on /dev
# since that is the conventional place for them.
#

create_dev_symlinks() {
    [ $devdir == /dev ] && return
    for d in $devdir/*; do
	if [ -c $d ]; then
	    f=${d##*/}
	    if [ ! -L /dev/$f -o ! -e /dev/$f ]; then
		[ -L /dev/$f  -o -e /dev/$f ] && rm /dev/$f
		echo "doing ln -s $d /dev"
		ln -s $d /dev
	    fi
	fi
    done
}

create_devices() {
	modules=($(get_modules))
	for m in ${modules[*]}; do
	    case "$m" in
	      usbtwod)
                [ -c /dev/usbtwod_64_0 ] || mknod /dev/usbtwod_64_0 c 180 192
                [ -c /dev/usbtwod_64_1 ] || mknod /dev/usbtwod_64_1 c 180 193
                [ -c /dev/usbtwod_64_2 ] || mknod /dev/usbtwod_64_2 c 180 194
                [ -c /dev/usbtwod_64_3 ] || mknod /dev/usbtwod_64_3 c 180 195
                [ -c /dev/usbtwod_32_0 ] || mknod /dev/usbtwod_32_0 c 180 196
                [ -c /dev/usbtwod_32_1 ] || mknod /dev/usbtwod_32_1 c 180 197
                [ -c /dev/usbtwod_32_2 ] || mknod /dev/usbtwod_32_2 c 180 198
                [ -c /dev/usbtwod_32_3 ] || mknod /dev/usbtwod_32_3 c 180 199
                ;;
	      pc104sg)
                MAJOR=`awk "\\$2==\"irig\" {print \\$1}" /proc/devices`
                if [ -n "$MAJOR" ] ; then
                    rm -f /dev/irig0                  # remove stale nodes
                    mknod /dev/irig0 c $MAJOR 0
                    echo "mknod /dev/irig0 c $MAJOR 0"
                fi
                ;;
	      ncar_a2d)
                MAJOR=`awk "\\$2==\"ncar_a2d\" {print \\$1}" /proc/devices`
                if [ -n "$MAJOR" ] ; then
                    rm -f /dev/ncar_a2d[01]              # remove stale nodes
                    mknod /dev/ncar_a2d0 c $MAJOR 0
                    mknod /dev/ncar_a2d1 c $MAJOR 1
                    echo "mknod /dev/ncar_a2d0 c $MAJOR 0"
                    echo "mknod /dev/ncar_a2d1 c $MAJOR 1"
                fi

                MAJOR=`awk "\\$2==\"ncar_a2d_boardtemp\" {print \\$1}" /proc/devices`
                if [ -n "$MAJOR" ] ; then
                    rm -f /dev/ncar_a2d_boardtemp[01]    # remove stale nodes
                    mknod /dev/ncar_a2d_boardtemp0 c $MAJOR 0
                    mknod /dev/ncar_a2d_boardtemp1 c $MAJOR 1
                    echo "mknod /dev/ncar_a2d_boardtemp0 c $MAJOR 0"
                    echo "mknod /dev/ncar_a2d_boardtemp1 c $MAJOR 1"
                fi
                ;;
	      *)
                echo "unusable module '$m'"
                ;;
	    esac
	done
}

# load the modules read from stdin. This can't use
# get_modules because it needs the whole module line
load_modules() {
    # depmod
    while read -a modline; do
	echo "${modline[@]}" | egrep -q "^ *$" && continue	# empty line
	echo "${modline[@]}" | egrep -q "^ *#" && continue	# comment line
        insmod_chk "${modline[@]}"
    done
    if [ -n "$vulcan" ]; then
	create_devices < $modconf
    else
	create_dev_symlinks
    fi
}

unload_modules() {
    # use tac (reverse cat) to read stdin backwards since we
    # want to unload the modules in the reverse order
    # modules=($(tac -| get_modules))
    # for m in ${modules[*]}; do
    #     rmmod_chk $m
    # done

    # unfortunately tac doesn't exist in busybox on embedded systems
    # so we'll go through the array backwards.
    modules=($(get_modules))
    for (( i=${#modules[*]}-1; i >= 0; i-- )); do
        [ ${modules[$i]} == rtl ] && continue	# don't unload rtl.o
        rmmod_chk ${modules[$i]}
    done
}

copy_firmware() {
	[ -d $fmwpath ] || mkdir -p $fmwpath
	modules=($(get_modules))
	for m in ${modules[*]}; do
	    [ $m == mesa ] && rsync -rlptDzv \
	    $ruser@$server:$adspath/firmware/mesa_fpga_file.bit      $fmwpath/
	done
}

copy_modules() {
	[ -d $modpath ] || mkdir -p $modpath
	modules=($(get_modules))
	for m in ${modules[*]}; do
            [ $m == rtl ] && continue	# don't fetch rtl.o
	    if [ -n "$vulcan" ]; then
	        rsync -rlptDzv $ruser@$server:$adspath/linux/$m.ko   $modpath/
	    else
	        rsync -rlptDzv $ruser@$server:$adspath/rtlinux/$m.o  $modpath/
	    fi
	done
}

copy_apps() {
        [ -d $libpath ] || mkdir -p $libpath
        [ -d $ftrpath ] || mkdir -p $ftrpath
	rsync -rlptDzv $ruser@$server:$adspath/lib/libnidas.so       $libpath/
	rsync -rlptDzv $ruser@$server:$adspath/lib/libnidas_dynld.so $libpath/
	rsync -rlptDzv $ruser@$server:$adspath/bin/dsm               $dsmpath/
	rsync -rlptDzv $ruser@$server:$adspath/filters/\*.cfg        $ftrpath/
}

start_app() {
        cd $dsmpath
	# start-stop-daemon --start --quiet --pidfile /var/run/$NAME.pid \
	# 	-b --exec $DAEMON
	./dsm > /var/log/dsm.log 2>&1 &
}

stop_app() {
        # cd $dsmpath
	# start-stop-daemon --stop --quiet --pidfile /var/run/$NAME.pid \
 	# 	--exec $DAEMON
 	echo "sending TERM to dsm"
 	pkill -TERM dsm
 	i=0
 	while [ $i -lt 5 ]; do
	 	sleep 2
	 	pgrep dsm || break
		i=$((i+1))
 	done
 	if [ $i -eq 5 ]; then
	 	echo "doing kill -9"
	 	pkill -9 dsm
	fi
}

#
# Crude way to sync a clock, using ssh and the date command.
crude_set_date() {
    echo "setting date from $server"
    datestr=`ssh $ruser@$server date -u +%m%d%H%M%Y.%S`
    echo "date on server is $datestr"
    date -s $datestr
    hwclock --systohc
}

# Clock on Vipers is not battery-backed, and reads
# 2000 Jan 1 at boot time. So if year is 2000
# then pound away with ntpdate.  If still no success
# try crude_set_date
check_ntp() {

    [ $(date +%Y) -ne 2000 ] && return

    # figure out timeserver from /etc/ntp.conf (taken from init.d/ntpd)
    timeserver=(`awk '$1=="peer"||$1=="server"{print $2}' /etc/ntp.conf |fgrep -v 127.127.1.0`)
    if [ ${#timeserver[*]} -gt 0 ]; then
        timeserver=${timeserver[0]}
    else
        timeserver=server
    fi
    # echo "timeserver=$timeserver"
     
    /etc/init.d/ntpd stop
    i=0
    while [ $i -lt 60 -a $(date +%Y) -eq 2000 ]; do
	sleep 5
	# for some reason on the dsms, logging to facility kern.info
	# doesn't get sent to the remote syslog server, but
	# rtl_printfs from RTL kernel modules do. Must be something
	# to do with klogd/syslogd interaction.
	# So here we log to local5 instead.
	ntpdate $timeserver | /usr/bin/logger -p local5.info -t ntpdate 2>&1
	i=$((i+1))
    done
    [ $(date +%Y) -eq 2000 ] && crude_set_date

    # since the system clock isn't battery backed, updating the
    # system clock only helps keep the time if one does a soft reboot.
    hwclock --systohc
    /etc/init.d/ntpd start
}

# mount the compact flash card
mounted=(`mount | grep code`)
[ -z "$mounted" ] && mount $dsmpath

# get devdir and create it
devdir=$(get_devdir < $modconf)
[ -d $devdir ] || mkdir -p $devdir
# echo "devdir=$devdir"

case "$1" in
  start)
	echo -n "Starting $DESC (fetch & load modules, fetch app, run app): "
        [ -d $dsmpath ] || mkdir -p $dsmpath
	check_ntp
	unload_modules < $modconf
	copy_firmware < $modconf
	copy_modules < $modconf
	load_modules < $modconf
	copy_apps
	/etc/init.d/pcmcom8 start
	start_app
	echo "$NAME."
	;;
  stop)
	echo -n "Stopping $DESC: "
	stop_app
	unload_modules < $modconf
	echo "$NAME."
	;;
  restart)
	echo -n "Restart of $DESC app (does not reload modules): "
	stop_app
	sleep 5
	start_app
	echo "$NAME."
	;;
  load)
	echo -n "Load of $DESC modules: "
	load_modules < $modconf
	;;
  unload)
	echo -n "Unload of $DESC (stops app, unloads modules): "
	stop_app
	sleep 5
	unload_modules < $modconf
	;;
  reload)
	echo -n "Reload of $DESC (stops app, reloads modules): "
	stop_app
	sleep 5
	unload_modules < $modconf
	load_modules < $modconf
	;;
  refetch)
	echo -n "Refetch of $DESC (stops app, fetches app & lib, starts app): "
        stop_app
        copy_apps
	start_app
	;;
  refetch_all)
	echo -n "Refetch_all of $DESC (stops app, unloads mods, fetches all, starts app): "
        stop_app
	unload_modules < $modconf
	copy_firmware < $modconf
	copy_modules < $modconf
	load_modules < $modconf
        copy_apps
	start_app
	;;
  test)
	# get_modules < $modconf
	# get_devdir < $modconf
	check_ntp
	;;
  *)
	N=/etc/init.d/$NAME
	echo "Usage: $N {start|stop|restart|load|unload|reload|refetch|refetch_all}" >&2
	exit 1
	;;
esac

exit 0

